# 数据结构

### 基础

#### 数据的逻辑结构

- 集合：集合中的元素之间除了同属于一个集合的特性外，数据元素之间无其他关系，他们之间的关系成为松散性的。
- 线性结构：除第一个和最后一个数据元素外每个数据元素只有一个前驱数据元素和一个后继数据元素。即数据元素之间存在一对一关系。


- 树状结构：除根节点外每个数据元素只有一个前驱数据元素，可有零个或若干个后继数据元素。即数据元素之间存在一对多关系。
- 图结构：每个数据元素可有零个或若干个前驱数据元素，可有零个或若干个后继数据元素。即数据元素之间存在多对多关系。

#### 数据的存储结构

- 顺序存储结构：顺序存储方式是指将所有的数据元素存放在一片连续的存储空间中，并使逻辑上相邻的数据元素其对应的物理位置也相邻，即数据元素的逻辑位置关系与物理位置关系保持一致。
- 链式存储结构：链式存储方式不要求逻辑上相邻的数据元素存储在物理位置上也相邻，即数据元素可以存储在任意物理位置上。每一个数据元素对应的存储表示由两部分组成，一部分存放数据元素本身，另外一部分用于存放逻辑关系的指针，即数据元素之间的逻辑关系是由附加的指针来表示的。
- 索引存储结构：索引存储方式在存储数据元素的同时，还增设了一个索引表。索引表中的每一项包括关键字和地址，其中关键字是能够唯一标识一个数据元素的数据项，地址是指示数据元素的存储地址或存储区域的首地址。
- 散列存储方式：散列存储（也称哈希存储）方式是指数据元素存储在一片连续的区域内，每一个数据元素的具体存储地址是根据该数据元素的关键字值，通过散列（哈希）函数直接计算出来的。

在以上4中存储方式中，顺序存储和链式存储是两种最基本最常用的存储方式。索引存储和散列存储是两种为了提高查找效率而经常采用存储方式。



算法的时间复杂度：O(1) < O(log₂n) < O(n) < O(nlog₂n) < O(n²) < O(n³)

#### 数据的操作

创建操作：建立数据存储结构。

销毁操作：对已经存在的存储结构将其多有空间释放。

插入操作、删除操作、查找操作、修改操作、遍历操作。



## 线性列表

#### 线性表的顺序存储及实现

定义：顺序存储的线性表。

特点：

- 在线性表中逻辑上相邻的数据元素，在物理位置上也是相邻的。
- 便于随机存取
- 不便于插入和删除操作，这是因为在顺序表上进行插入和删除操作会引起大量数据元素的移动。

#### 顺序表上基本操作的实现

##### 1.顺序表上的插入操作

根据顺序表的存储特点，要在数据元素之前插入一个新的数据元素，则需要将该数据元素后面的所有的数据元素后移一个存储位置。步骤如下：

1. 判断当前顺序表的存储空间是否已满，若满则抛出异常。思考：若存储空间满则要求为线性表扩充存储空间，扩充后再进行插入操作，算法应该如何修改？
2. 判断插入参数x的合法性，若不合法则抛出异常。当0《=x《=curLen时即为合法。
3. 确定插入位置。
4. 将插入位置及其之后的所有数据元素后移一个存储位置。注意：必须先从最后一个数据元素开始依次逐个后移，直到第i个数据元素移动完毕为止。
5. 表长加1。 

插入操作算法如下：时间复杂度为O(n)

```
public void insert(int i,Object x) throws Exception{
  if(curLen == listElem.length){              //判断顺序表是否已满
    throw new Exception("顺序表已满");
  }
  if(i<0 || i>curLen){
    throw new Exception("插入为止不合法");      //判断是否合法
  }
  for(int j = curLen ; j > i ; j--){
    listElem[j] = listElem[j-1];               //插入位置及其之后的所有数据元素后移一个存储位置
  }
  listELem[i] = x;                             //插入X
  curLen++;                                    //表长加1
}
```

##### 2.顺序表上的删除操作

根据顺序表的存储特点，要删除一个数据元素，则需要将该数据元素后面的所有的数据元素向前移一个存储位置。步骤如下：

1. 判断参数的合法性，若不合法则抛出异常。
2. 将第i个数据元素之后的所有数据元素向前移动一个存储位置。
3. 表长减1。

顺序表删除操作算法：时间复杂度为O(n)

```
public void remove(int i) throws Exception{
  if(i<0 || i>curLen-1){
    throw new Exception("删除位置不合法");      //判断是否合法
  }
  for(int j = i ; j < curLen-1 ; j++){
    listElem[j] = listElem[j+1]                //被删除元素之后的所有数据元素左移一个存储位置
  }
  curLen--;                                    //表长减1
}
```

##### 3.顺序表的查找操作

查找有两种，一是查找指定位置上的数据元素的值，另一种是查找满足条件的数据元素初次出现的位置。

第一种实现很简单，用随机存取的方式就可以找到对应的数据元素，其时间复杂度为O(1)

第二种实现方法为是将x与顺序表的每一个数据元素依次进行比较，若相等则返回该数据元素的位序号。若与所有数据元素都不相等，说明x数据元素在顺序表中并不存在，返回-1。

顺序表的查找操作算法：时间复杂度位O(n)

```
public int indexOf(Object x){
  int j = 0;                                //j指示顺序表中待比较的数据元素，其初始值为第0个数据元素
  while(j<curLen && listElem[j].equals(x)){ //依次比较
    j++;
  }
  if(j<curLen){                             //判断j的位置师傅位于顺序表中
    return j;                               //返回值为x的数据元素在顺序表中的位置
  }else{
    return -1;                              //值为x的数据元素在顺序表中不存在
  }
}
```

顺序表的缺点：

- 若要位线性表扩充存储空间，则需要重新创建一个地址连续的更大的存储空间，并把原有的数据元素都复制到新的存储空间中。
- 增删数据元素会引起平均约一半的数据元素移动。

### 线性表的链式存储及其实现

定义：采用链式存储方式存储的线性表。

特点：

- 单链表中每一个节点包含存放数据元素值的数据域和存放指向逻辑上相邻节点的指针域。

结点类

```
public class Node{
  public Object data;    //存放结点值
  public Node next;      //后继结点的引用
  //无参构造函数
  pulbic Node(){
    this(null,null)
  }
  //一个参数的构造函数
  pulbic Node(Object data){
    this(data,null)
  }
  //两个参数的构造函数
  pulbic Node(Object data,Node next){
    this.data = data ;
    this.next = next ;
  }
}
```

#### 单链表上基本操作的实现

单链表的操作分为带头节点和不带头结点。

##### 1.链表上的查找操作

1）按位序号查找（时间复杂度为O(n)）

由于单链表的存储空间不连续，所以不能像顺序表那样通过为序号随机存取，单链表是顺序存取结构，即要取到第i个结点的值，只能从头指针所指的结点开始依次查找。

```
public Object get(int i) throws Exception{
  Node p = head.next;    //初始化，p指向首个结点，j为计数器
  int j = 0 ;
  while(p!=null && j<i){ //从首结点开始先后查找，直到p指向第i个结点或p为空
    p = p.next;          //指向后继结点
    ++j;                 //计数器的值增1
  }
  if(j>i || p==null){    //i小于0或者大于表长减一是，i不合法
    throw new Exception("第"+i+"个元素不存在");
  }
  return p.data;         //返回结点p的数据域值
}
```

2）按值查找（时间复杂度为O(n)）

从单链表首结点开始依次对各结点的数据域值与x值进行比较。

```
public Object indexOf(Object x){
  Node p = head.next;    //初始化，p指向首个结点，j为计数器
  int j = 0 ;
  //从首结点开始先后查找，直到p.data等于x或到达单链表的表尾
  while(p!=null && !p.data.equals(x)){ 
    p = p.next;          //指向后继结点
    ++j;                 //计数器的值增1
  }
  if(p!=null){
     return j;           //返回值位x的结点在单链表中的位置
  }else{
     return -1;          //值为x的结点不存在与单链表中，返回-1
  }
}
```

##### 2.链表上的插入操作

在带头结点的单链表的第i个结点之前插入一个数据域值为x的新节点，需要将新节点的后继指针域的值设置为前驱结点的指针域的值，而前驱结点的后继指针域的值指向新节点。所以必须现缺点第i-1个结点。步骤如下

- 查找到带插入未知的前驱结点
- 创建数据域值为x的新节点
- 修改相关结点的指针域值从而使新节点插入到单链表指定的位置上

带头结点的单链表上的插入算法：（时间复杂度为O(n)）

```
public void insert(int i,Object x)throws Exception{
  Node p = head;               //初始化p为头结点，j为计数器
  int j = -1;
  while(p!=null && j<i-1){     //寻找第i个结点的前驱
    p = p.next;
    ++j;                       //计数器增1
  }
  if(j>i-1 || p==null){
    throw new Exception("插入位置不合法");
  }
  Node s = new Node(x);        //生成新结点
  s.next = p.next;             //修改链表的值，使新节点插入到单链表中
  p.next = s;				   //这两个语句顺序不可颠倒
}
```

**注意**：

- 链式存储是动态分配存储空间，所以在插入操作之前无需判断存储空间是否已满
- 算法在常数时间（O(1)）内完成创建新节点和修改链表的操作,单查找到第i-1个结点的时间复杂度是O(n),所以插入算法的时间复杂度是O(n)
- 在带头结点单链表上进行插入操作无论是插入表头，表尾操作语句都是一样的。但是在不带头结点的的单链表上进行插入操作的语句是不相同的。
- 新节点插入到不带头结点的单链表的表头，需要将新节点s的后继指针指向原理单链表的第一个结点，并且将头指针指向新结点对应语句为

```
s.next = head;
head = s;
//若是在不带头结点的单链表的中间位置或表尾插入一个新结点，修改语句与带头结点单链表的语句相同
s.next = p.next;
p.next = s;
```

##### 3.单链表上的删除操作

操作步骤如下：（时间复杂度为O(n)）

- 判断单链表是否为空，若为空则操作结束
- 查找到待删除的结点的前驱结点
- 修改指针，使待删除结点从单链表中脱离出来

```
public void remove(int i) throws Exception{
  Node p = head;
  int j = -1;
  while(p.next!=null && j<i-1){
    p = p.next;
    ++j;
  }
  if(j>i-1 ||p.next ==null){
    throw new Exception("删除位置不合法");
  }
  p.next = p.next.next; //修改连接指针，使待删除结点从单链表中脱离出来
}
```

循环链表：将单链表的最后一个结点的后继指针指向第一个结点。

双向链表：包含两个指针，一个指向前驱结点，另一个指向后继结点。

### 顺序表与链表的比较

顺序表：静态线性表，适合场景：数据元素相对固定，需要频繁访问

链表：动态线性表，是和场景：数据元素需要频繁插入和删除，访问较少，链表的空间利用率低

# 参考阅读

本文部分摘自《数据结构——java语言描述（第2版）》   刘小晶、杜选主编   清华大学出版社